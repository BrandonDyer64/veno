#!/usr/bin/python3
import string

import argparse	# venic is required to be started with a filename, need to parse the arg for it
parser = argparse.ArgumentParser()	# initialize argument parser
parser.add_argument("filename")	# add an argument to our program, we need a file
args = parser.parse_args()	# actually parse the arguments Venic was given

file = open(args.filename,'r+')	# try to grab the file requested into its own object
lines = [line.rstrip('\n') for line in file]	# assign. to a lines array, the newline-stripped content of each line.
file.close()

if lines == []:
	lines = [""]

global viewport, filecursor

def updateScreen():
	stdscr.clear()	# clear the screen. it may, later in the future, be more efficient to know what characters have been changed, and fix only those, but for now we can afford clearing the whole screen.
	screeny = 0
	global screenCursor
	neededCursorSpaces = 0
	neededStringLength = 0
	screenCursor = [0,0]
	screenCursor[1] = filecursor[1]-viewport[1]
	lineNumber = viewport[1]+1
	for line in lines[viewport[1]:]:
		if screeny >= stdscr.getmaxyx()[0]-1:
			break

		lineindex = 0
		screenlineindex = lineindex
		tabColumn = 4 - 1	# the 8 is how many 'spaces' you want a tab to be, the minus one is due to implementation :T
		tabColumnIncrease = tabColumn + 1
		spacedString = ""
		for character in line:
			if screenlineindex-viewport[0] >= stdscr.getmaxyx()[1]-1:
				break

			if filecursor[1]-viewport[1] == screeny:
				if lineindex == filecursor[0]:
					neededCursorSpaces = spacedString.count("\xA0")
					neededStringLength = len(spacedString.replace("\xA0",""))

			if character == "\t":
				while tabColumn < screenlineindex:
					tabColumn += tabColumnIncrease
				neededSpaces = (tabColumn+1) - screenlineindex
				spacedString += "\xA0"*neededSpaces
				screenlineindex += neededSpaces
			else:
				spacedString += character
				screenlineindex += 1

			if filecursor[1]-viewport[1] == screeny:
				if filecursor[0] == len(line):
					neededCursorSpaces = spacedString.count("\xA0")
					neededStringLength = len(spacedString.replace("\xA0",""))

			lineindex += 1

		stdscr.move(screeny,0)
		
		lineNumberStringPrefix = str(lineNumber)+" "*( len(str(len(lines)))-len(str(lineNumber)) )+"\u2503"
		spacedString = lineNumberStringPrefix+spacedString[viewport[0]:]
		stdscr.addnstr(spacedString,stdscr.getmaxyx()[1], curses.color_pair(35))
		
		if filecursor[1] == viewport[1]+screeny:
			screenCursor[0] = len(lineNumberStringPrefix)+neededCursorSpaces+neededStringLength-viewport[0]
			if screenCursor[0] > len(lineNumberStringPrefix)-1 and screenCursor[0] < stdscr.getmaxyx()[1] and (filecursor[0] < lineindex or lineindex == 0 or lineindex == len(line)):
				stdscr.chgat(screenCursor[1],screenCursor[0], 1, curses.A_REVERSE)

		screeny += 1
		lineNumber += 1
	
	stdscr.refresh()	# refresh the screen. it's the least you can do


def moveViewportDown():
	viewport[1] += 1
def moveViewportUp():
	if viewport[1] > 0:
		viewport[1] -= 1
def moveViewportRight():
	viewport[0] += 1
def moveViewportLeft():
	if viewport[0] > 0:
		viewport[0] -= 1

def moveFileCursorRight():
	if filecursor[0] < len(lines[filecursor[1]]):
		filecursor[0] += 1
	elif filecursor[0] == len(lines[filecursor[1]]):
		moveFileCursorDown()
		gotoStartOfLine()

	if screenCursor[0] >= stdscr.getmaxyx()[1]-1:
		moveViewportRight()
def moveFileCursorLeft():
	if filecursor[0] > 0:
		filecursor[0] -= 1
	elif filecursor[0] == 0:
		moveFileCursorUp()
		gotoEndOfLine()
def moveFileCursorDown():
	if filecursor[1] < len(lines)-1:
		filecursor[1] += 1
		if filecursor[0] > len(lines[filecursor[1]])-1:
			if len(lines[filecursor[1]]) > 0:
				filecursor[0] = len(lines[filecursor[1]])-1
			elif len(lines[filecursor[1]]) == 0:
				filecursor[0] = 0
	while filecursor[1] > stdscr.getmaxyx()[0]+viewport[1]-2:
		moveViewportDown()
	while filecursor[1] < viewport[1]:
		moveViewportUp()
def moveFileCursorUp():
	if filecursor[1] > 0:
		filecursor[1] -= 1
		if filecursor[0] > len(lines[filecursor[1]])-1:
			if len(lines[filecursor[1]]) > 0:
				filecursor[0] = len(lines[filecursor[1]])-1
			elif len(lines[filecursor[1]]) == 0:
				filecursor[0] = 0
	while filecursor[1] < viewport[1]:
		moveViewportUp()
	while filecursor[1] > stdscr.getmaxyx()[0]+viewport[1]-2:
		moveViewportDown()


def enterTextAtFileCursor(text):
	lineStringLeft = lines[filecursor[1]][:filecursor[0]]
	lineStringRight = lines[filecursor[1]][filecursor[0]:]
	lineStringLeft += text
	lines[filecursor[1]] = lineStringLeft+lineStringRight
	moveFileCursorRight()

def gotoEndOfLine():
	filecursor[0] = len(lines[filecursor[1]])
def gotoStartOfLine():
	filecursor[0] = 0

def backspaceTextAtFileCursor():
	if filecursor[0] == 0:
		if filecursor[1] > 0:
			lineString = lines[filecursor[1]]
			lines.pop(filecursor[1])
			moveFileCursorUp()
			gotoEndOfLine()
			lines[filecursor[1]] += lineString
	else:
		lineStringLeft = lines[filecursor[1]][:filecursor[0]-1]
		lineStringRight = lines[filecursor[1]][filecursor[0]:]
		lines[filecursor[1]] = lineStringLeft+lineStringRight
		moveFileCursorLeft()

def newLineAtFileCursor():
	lineStringLeft = lines[filecursor[1]][:filecursor[0]]
	lineStringRight = lines[filecursor[1]][filecursor[0]:]
	lines[filecursor[1]] = lineStringLeft
	lines.insert(filecursor[1]+1,"")
	moveFileCursorDown()
	lines[filecursor[1]] = lineStringRight

def saveFile():
	file = open(args.filename,'w')	# try to grab the file requested into its own object
	fileString = ""
	linesRow = 0
	for line in lines:
		fileString += line+"\n"
	fileString = fileString[:-1]	# get rid of the trailing newline
	file.write(fileString)
	file.close()
	
def handleKeyboard(c):
	if c == curses.KEY_DOWN:
		moveFileCursorDown()
	if c == curses.KEY_UP:
		moveFileCursorUp()
	if c == curses.KEY_RIGHT:
		moveFileCursorRight()
	if c == curses.KEY_LEFT:
		moveFileCursorLeft()
	if c == 525:	# C-down
		moveViewportDown()
	if c == 566:	# C-up
		moveViewportUp()
	if c == 560:	# C-right
		moveViewportRight()
	if c == 545:	# C-left
		moveViewportLeft()
	if c == curses.KEY_BACKSPACE:
		backspaceTextAtFileCursor()
	if chr(c) == "\n":
		newLineAtFileCursor()
	if chr(c) in string.punctuation+string.digits+string.ascii_letters+" \t":
		enterTextAtFileCursor(chr(c))
	if c == 15:	# C-o
		saveFile()
	if c == curses.KEY_HOME:
		gotoStartOfLine()
	if c == curses.KEY_END:
		gotoEndOfLine()
import curses	# our lovely buddy for making the terminal not hell.
stdscr = curses.initscr()	# give us a WindowObject to work with.
curses.start_color()
curses.curs_set(0)
curses.use_default_colors()
for i in range(0,curses.COLORS):
	curses.init_pair(i+1,i,-1)

def runVenic(self):
	global viewport, filecursor
	viewport = [0,0]
	filecursor = [0,0]
	updateScreen()
	while 1:
		c = stdscr.getch()
		handleKeyboard(c)
		updateScreen()
curses.wrapper(runVenic)